\documentclass[12pt,preprint]{aastex}
%\documentclass{emulateapj}
\usepackage{url}
%\usepackage{natbib}
%\usepackage{xspace}
\def\arcsec{$^{\prime\prime}$}
\bibliographystyle{apj}
\newcommand\degree{{^\circ}}
\newcommand\surfb{$\mathrm{mag}/\square$\arcsec}
\newcommand\Gyr{\rm{~Gyr}}
\newcommand\msun{\rm{M}_\odot}
\newcommand\kms{km s$^{-1}$}
\newcommand\al{$\alpha$}
\newcommand\ha{$\rm{H}\alpha$}
\newcommand\hb{$\rm{H}\beta$}



%\shorttitle{Short Title}
%\shortauthors{Yoachim et al.}

\begin{document}

\title{An Object Oriented Feature-Based Scheduler}


\author{Peter Yoachim, Elahesadat Naghib}
%\altaffiltext{1}{Department of Astronomy, University of Washington, Box 351580,
%Seattle WA, 98195; {yoachim@uw.edu} }

\section{Features}
Features form the foundation of the scheduler. Features can take many forms, but most commonly they are HEALpixel maps that describe the current state of the sky and telescope or progress of the telescope. Some example features include:
\begin{itemize}
    \item{A map of the number of completed observations}
    \item{A map of the desired number of observations at each point in the sky}
    \item{The currently loaded filter}
    \item{The currently observable HEALpixels}
    \item{The sky brightness at each HEALpixel in each filter}
\end{itemize}
Example feature maps are show in Figure~\ref{features}

\begin{figure}
\epsscale{.5}
\plotone{no_feature.pdf}
\plotone{depth_feature.pdf}
\caption{Example features from a simple 5-day simulation. Left show the number of times each HEALpixel has been observed. Right shows the current five-sigma limiting depth percentile with masks for zenith, high airmass, and near the moon. \label{features}}
\end{figure}


\section{Basis Functions}
Basis functions are built by combining features and reflect the relative reward of observing different regions of the sky.

\begin{figure}
\epsscale{.5}
\plotone{goal_map.pdf}
\caption{A typical goal map for how LSST observations should be distributed. \label{goal}}
\end{figure}


\begin{figure}
\epsscale{.5}
\plotone{visit_bf.pdf}
\plotone{depth_bf.pdf}
\caption{The basis functions for the simulation after 5 days. Left shows how the number of observations made is combined with the goal map to generate a basis function that prioritizes under-observed regions and penalizes over-observed areas. Right shows the depth basis function, which is the unmodified depth percentile feature.\label{basis_funcs}}
\end{figure}


\section{Reward and Decision Functions}

The final reward function (also commonly called a "cost function") is calculated as a linear combination of the basis functions. The free parameters of the scheduler are thus the weights assigned to each basis function. Once the final reward function is computed, a decision function selects observation(s) to attempt. A simple greedy algorithm would select the position with the highest reward. One can also smooth the map and select a large region to observe. Because most features change on long timescales, the resulting reward function should also be slowly varying, allowing the decision function to queue up several observations.


\begin{figure}
\epsscale{.5}
\plotone{reward.pdf}
\caption{The final reward function generated by a linear combination of the basis functions in Figure~\ref{basis_funcs}. In this particular simulation we gave the observing history a weight of 1 and the depth basis function a weight of 10.\label{goal}}
\end{figure}



\section{Performance Function and Optimization}

A performance function can be written that analyzes the performance of the survey, e.g., combining the total number of visits, fraction of recovered NEOs, and number of good supernova lightcurves into a single scaler. The scheduler free parameters can then be optimized to maximize the performance function. 

\section{Discussion}
In the sims\_featureScheduler package, we have implemented features and basis functions as python classes. We have then added a survey class which takes a list of basis functions and weights to compute a reward function. Each filter can then be it's own survey.

Some advantages of a feature-based scheduler:
\begin{itemize}
    \item{Object oriented nature of the code makes it possible to include other arbitrary schedulers (e.g., pre-scheduled deep drilling field observations).}
    \item{Users have direct access to the reward function, making small or large changes to the observing strategy possible.}
    \item{Easy to develop and debug new observing strategies as all the inputs to the reward function can be easily accessed and visualized.}
    \item{High spatial resolution features make it possible to easily include dithering experiments in the scheduling algorithm.}
    \item{By using high spatial resolution, the feature-based scheduler can incorporate any arbitrary camera geometry, such as a single raft commissioning camera.}
    \item{HEALpixel based features make it easy to compute the cost function efficiently with numpy}
    \item{All our data structures are picklable, so we can use python multiproccessing to get a factor of 6 speedup computing reward functions by running each filter on it's own processor.}
\end{itemize}




%\begin{figure}
%\epsscale{.5}
%\caption{ \emph{continued}.}
%\end{figure}




\end{document}